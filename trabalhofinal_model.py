# -*- coding: utf-8 -*-
"""TrabalhoFinal-Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZXwErQu0ucAFEOja_am1L0sYgGVCXWF7
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pickle
import seaborn as sns
from sklearn import metrics
from sklearn.datasets import make_classification
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, precision_recall_fscore_support
from sklearn.model_selection import GridSearchCV, StratifiedKFold
from sklearn.preprocessing import KBinsDiscretizer as kbd, MinMaxScaler
import warnings
warnings.filterwarnings('ignore')

df_nba = pd.read_csv('df_1980_2020.csv', sep = ',', decimal = '.')

df_nba.info()

# Dividir dataset em treino/teste (até 2019) e predição (2020)
df_nba_1980_2019 = df_nba[df_nba.Season <= 2019]
df_nba_2020 = df_nba[df_nba.Season == 2020]

df_nba_1980_2019.info()

# Verificar correlações de todas as variáveis com a variável 'Share'
corr = df_nba_1980_2019.corr(method = 'pearson')
share_corr = corr[['Share']]
share_corr.Share.abs().sort_values()

# Conforme resultado acima, não há correlações boas com a variável 'Share'

# Filtrando por jogadores que receberam pontos na votação do prêmio
len(df_nba_1980_2019[(df_nba_1980_2019['Pts Won'] > 0)]['Pts Won'])

# Conforme resultado acima, de 18.520 registros, apenas 653 receberam pontos na premiação, ou seja, 3,5% dos jogadores

# Filtrando dataset para atender a regra acima
df_nba_1980_2019_filtered = df_nba_1980_2019[df_nba_1980_2019['Pts Won'] > 0]
df_nba_1980_2019_filtered.info()

df_nba_1980_2019_filtered['MVP Rank'] = df_nba_1980_2019_filtered.groupby('Season')['Pts Won'].rank(ascending = False, method = 'dense')
df_nba_1980_2019_filtered['Won MVP'] = np.where(df_nba_1980_2019_filtered['MVP Rank'] == 1, 1, 0)

# Verificar correlações de todas as variáveis com a variável 'Share'
corr = df_nba_1980_2019_filtered.corr(method = 'pearson')
share_corr = corr[['Won MVP']]
share_corr['Won MVP'].abs().sort_values()

df_nba_1980_2019_filtered.tail(15)

# Método para gerar gráficos
def plot_two_variables(title, var1, var1_order, var2, var2_order):
    plt.style.use('fivethirtyeight')
    fig, ax = plt.subplots()

    mvp = df_nba_1980_2019_filtered[df_nba_1980_2019_filtered['Won MVP'] == 1]
    non_mvp = df_nba_1980_2019_filtered[df_nba_1980_2019_filtered['Won MVP'] != 1]

    ax.scatter(mvp[var1], mvp[var2], label = 'MVP', marker = '^', s = 100)
    ax.scatter(non_mvp[var1], non_mvp[var2], label = 'Não MVP', alpha = .2)

    ax.legend(loc = 'best', prop = {'size': 9, 'family': 'Rockwell'})

    ax.set_xlabel(var1)
    ax.set_ylabel(var2)

    ax.set_xlim(ax.get_xlim()[::var1_order])
    ax.set_ylim(ax.get_ylim()[::var2_order])
  
    fig.suptitle(title, weight = 'bold', size = 18)

plot_two_variables('Contribuição do jogador nas vitórias VS Classificação do time', 'Team Overall Seed', -1, 'WS', 1)

plot_two_variables('Eficiência VS Pontuação média do jogador', 'PTS', 1, 'PER', 1)

plot_two_variables('Classificação do time VS Valor de substituição do jogador', 'Team Overall Seed', -1, 'VORP', 1)

# Construir modelos
def build_models(alg):
    if alg == 'logistic_regression':
        model = LogisticRegression(solver = 'liblinear')
        return model
    else:
        raise Exception('Modelo não implementado')

# Construir features
def build_features(df_train, df_test):
    mms = MinMaxScaler()
    x_train_mms = mms.fit_transform(df_train[['VORP', 'WS', 'WS/48', 'BPM', 'PER', 'PTS', 'USG%', 'Team Overall Seed', 'TS%', 'eFG%', 'TOV', '2P%', 'MP', 'STL', 'GS', 'AST', 'FG%', 'PF', 'TRB', 'G', 'FT%' , 'BLK', '3P%', 'Age']])
    x_test_mms = mms.transform(df_test[['VORP', 'WS', 'WS/48', 'BPM', 'PER', 'PTS', 'USG%', 'Team Overall Seed', 'TS%', 'eFG%', 'TOV', '2P%', 'MP', 'STL', 'GS', 'AST', 'FG%', 'PF', 'TRB', 'G', 'FT%' , 'BLK', '3P%', 'Age']])

    x_train = np.hstack([x_train_mms])
    x_test = np.hstack([x_test_mms])

    y_train = df_train['Won MVP'].values.reshape(-1, 1)
    y_test = df_test['Won MVP'].values.reshape(-1, 1)

    return x_train, y_train, x_test, y_test

# Método para visualizar resultados
def print_result(algs, results_matrix):
    for alg_index, alg in enumerate(algs):
        if (alg_index > 0):
            print('-' * 50)

        print('Algoritmo:', alg)
        print()
        print('Treino')
        print('Acurácia:', results_matrix[alg_index, :, 0, 0].mean())
        print('Precisão:', results_matrix[alg_index, :, 1, 0].mean())
        print('Cobertura:', results_matrix[alg_index, :, 2, 0].mean())
        print('Medida F:', results_matrix[alg_index, :, 3, 0].mean())
        print()
        print('Teste')
        print('Acurácia:', results_matrix[alg_index, :, 0, 1].mean())
        print('Precisão:', results_matrix[alg_index, :, 1, 1].mean())
        print('Cobertura:', results_matrix[alg_index, :, 2, 1].mean())
        print('Medida F:', results_matrix[alg_index, :, 3, 1].mean())

# Execução segmentada (Treino: todas temporadas exceto a da vez / Teste: somente a temporada da vez)
df_pred = []

k = 2019 - 1980
algs = ['logistic_regression']
results_matrix = np.zeros(shape = (len(algs), k, 4, 2))
for alg_index, alg in enumerate(algs):
    for season in range(1980, 2019):
        fold = season - 1980 - 1
        df_train = df_nba_1980_2019_filtered[df_nba_1980_2019_filtered.Season != season]
        df_test = df_nba_1980_2019_filtered[df_nba_1980_2019_filtered.Season == season]

        x_train, y_train, x_test, y_test = build_features(df_train, df_test)

        model = build_models(alg)
        model.fit(x_train, y_train)

        # Treino
        y_pred_train = model.predict_proba(x_train)[:, 1]
        df_train_rank = df_train.copy()
        df_train_rank['Predicted MVP'] = y_pred_train

        df_train_rank['Predicted MVP Rank'] = df_train_rank.groupby('Season')['Predicted MVP'].rank(ascending = False, method = 'dense')

        df_train_rank['Predicted MVP Winner'] = df_train_rank['Predicted MVP Rank']
        df_train_rank['Predicted MVP Winner'].loc[df_train_rank['Predicted MVP Winner'] != 1] = 0

        df_train_rank_won_mvp = df_train_rank['Won MVP']
        df_train_rank_predicted_mvp_winner = df_train_rank['Predicted MVP Winner']

        results_matrix[alg_index, fold, 0, 0] = metrics.accuracy_score(df_train_rank_won_mvp, df_train_rank_predicted_mvp_winner)
        results_matrix[alg_index, fold, 1, 0] = metrics.precision_score(df_train_rank_won_mvp, df_train_rank_predicted_mvp_winner)
        results_matrix[alg_index, fold, 2, 0] = metrics.recall_score(df_train_rank_won_mvp, df_train_rank_predicted_mvp_winner)
        results_matrix[alg_index, fold, 3, 0] = metrics.f1_score(df_train_rank_won_mvp, df_train_rank_predicted_mvp_winner)

        # Teste
        y_pred_test = model.predict_proba(x_test)[:, 1]
        df_test_rank = df_test.copy()
        df_test_rank['Predicted MVP'] = y_pred_test

        df_pred.append(df_test_rank)

        df_test_rank['Predicted MVP Rank'] = df_test_rank.groupby('Season')['Predicted MVP'].rank(ascending = False, method = 'dense')

        df_test_rank['Predicted MVP Winner'] = df_test_rank['Predicted MVP Rank']
        df_test_rank['Predicted MVP Winner'].loc[df_test_rank['Predicted MVP Winner'] != 1] = 0

        df_test_rank_won_mvp = df_test_rank['Won MVP']
        df_test_rank_predicted_mvp_winner = df_test_rank['Predicted MVP Winner']

        results_matrix[alg_index, fold, 0, 1] = metrics.accuracy_score(df_test_rank_won_mvp, df_test_rank_predicted_mvp_winner)
        results_matrix[alg_index, fold, 1, 1] = metrics.precision_score(df_test_rank_won_mvp, df_test_rank_predicted_mvp_winner)
        results_matrix[alg_index, fold, 2, 1] = metrics.recall_score(df_test_rank_won_mvp, df_test_rank_predicted_mvp_winner)
        results_matrix[alg_index, fold, 3, 1] = metrics.f1_score(df_test_rank_won_mvp, df_test_rank_predicted_mvp_winner)

# Resultado da execução segmentada
print_result(algs, results_matrix)

df_pred = pd.concat(df_pred)
df_pred = df_pred[['Player', 'Season', 'Won MVP', 'Predicted MVP']]

df_pred['Predicted MVP Rank'] = df_pred.groupby('Season')['Predicted MVP'].rank(ascending = False, method = 'dense')

df_pred['Predicted MVP Winner'] = df_pred['Predicted MVP Rank']
df_pred['Predicted MVP Winner'].loc[df_pred['Predicted MVP Winner'] != 1] = 0

# Jogadores que ganharam o prêmio e o modelo preveu errado
df_pred[(df_pred['Won MVP'] == 1) & (df_pred['Predicted MVP Winner'] != 1)][['Player', 'Season', 'Predicted MVP Rank']]

# Jogadores que não ganharam o prêmio e o modelo preveu errado
df_pred[(df_pred['Won MVP'] != 1) & (df_pred['Predicted MVP Winner'] == 1)][['Player', 'Season']]

# Visualizar resultado da classificação
predicted = df_pred['Predicted MVP Winner']
ground_truth = df_pred['Won MVP']

print(classification_report(ground_truth, predicted))

# Normalizar matriz de confusão para visualizar o resultado da cobertura
cm = confusion_matrix(ground_truth, predicted)
cm = np.transpose(cm.T / cm.astype(np.float).sum(axis = 1))

plt.title('Matriz de confusão - Predição de MVP (Cobertura)')
sns.heatmap(cm, annot = True, fmt = '.2f', cmap = 'rocket_r')
plt.show()

# Normalizar matriz de confusão para visualizar o resultado da precisão
cm = confusion_matrix(ground_truth, predicted)
cm = np.transpose(cm.T / cm.astype(np.float).sum(axis = 0))

plt.title('Matriz de confusão - Predição de MVP (Precisão)')
sns.heatmap(cm, annot = True, fmt = '.2f', cmap = 'rocket_r')
plt.show()

# Visualizar matriz de confusão sem normalização
cm = confusion_matrix(ground_truth, predicted)

plt.title('Matriz de confusão - Predição de MVP (Sem Normalização)')
sns.heatmap(cm, annot = True, fmt = '.2f', cmap = 'rocket_r')
plt.show()

# Descobrir melhor parametrização
x_train, y_train, x_test, y_test = build_features(df_nba_1980_2019_filtered, df_nba_1980_2019_filtered)
model = build_models('logistic_regression')
model.fit(x_train, y_train)

# Visualizar threshold
for threshold in [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]:
    y_pred_prob = model.predict_proba(x_test)[:, 1]
    y_pred_prob = (y_pred_prob > threshold).astype(int)
    p, r, _, _ = precision_recall_fscore_support(y_test, y_pred_prob, average = 'binary')

    print('Threshold', threshold)
    print('Precisão', p)
    print('Cobertura', r)

# Pré-processamento para visualizar Regressão Logística
x, y = make_classification(n_samples = 50, n_features = 1, n_informative = 1, n_redundant = 0, n_clusters_per_class = 1, n_classes = 2)

logistic_regression = LogisticRegression()
logistic_regression.fit(x, y)

# Visualizar Regressão Logística (função sigmoid)
plt.scatter(x[y == 0], y[y == 0], c = 'blue')
plt.scatter(x[y == 1], y[y == 1], c = 'red')

new_x = np.linspace(-5, 5, num = 200)
new_y = list()

for n in new_x:
    prob = logistic_regression.predict_proba(n.reshape(-1, 1))
    new_y.append(prob[0, 1])

plt.plot(new_x, new_y, 'k--')
plt.show()

# Visualizar Regressão Logística (função da reta)
plt.scatter(x[y == 0], y[y == 0], c = 'blue')
plt.scatter(x[y == 1], y[y == 1], c = 'red')

new_x = np.linspace(-2, 2, num = 200)
new_y = list()

for n in new_x:
    _y = logistic_regression.intercept_ + (logistic_regression.coef_[0] * n)
    new_y.append(_y[0])

plt.plot(new_x, new_y, 'k--')
plt.show()

# Visualizar resultado da classificação
y_pred = logistic_regression.predict(x)
cm = confusion_matrix(y, y_pred)

print(cm)
print(classification_report(y, y_pred))

# Prever o MVP de 2020

# Informações básicas
df_nba_2020.info()

df_nba_2020['Won MVP'] = 0
mask2020 = (df_nba_2020.G > 55) & (df_nba_2020.GS > 55)
df_nba_2020 = df_nba_2020[mask2020]

# Cabeçalho
df_nba_2020.tail(15)

# Modelo produtivo
x_train, y_train, x_test, y_test = build_features(df_nba_1980_2019_filtered, df_nba_2020)
x_complete = x_train
y_complete = y_train

production_model = LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=100,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=None, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)

production_model.fit(x_complete, y_complete)

y_pred_prob = production_model.predict_proba(x_test)
df_nba_2020['Predicted MVP'] = y_pred_prob[:, 1]

df_nba_2020['Predicted MVP Rank'] = df_nba_2020.groupby('Season')['Predicted MVP'].rank(ascending = False, method = 'dense')

df_nba_2020['Predicted MVP Winner'] = df_nba_2020['Predicted MVP Rank']
df_nba_2020['Predicted MVP Winner'].loc[df_nba_2020['Predicted MVP Winner'] != 1] = 0

df_nba_2020.sort_values(by =['Predicted MVP Rank'], ascending = True).head(15)